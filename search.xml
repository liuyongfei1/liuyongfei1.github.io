<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[webpack系列之plugin及简单的使用]]></title>
      <url>%2F2018%2F04%2F24%2Fwebpack-plugin%2F</url>
      <content type="text"><![CDATA[webpack系列之plugin及简单的使用一.plugin有什么用 plugin是webpack核心功能，通过plugin（插件）webpack可以实现loader所不能完成的复杂功能，使用plugin丰富的自定义API，可以控制webpack编译流程的每个环节，实现对webpack的自定义功能扩展。 举例我们实际项目中就使用了HtmlWebpackPlugin插件，它帮助我们做了下面几件事儿： 在工程打包成功后会自动生成一个html模板文件 同时所依赖的CSS/JS也都会被自动引入到这个html模板文件中 设置生成hash添加在引入文件地址的末尾，类似于我们常用的时间戳，来解决可能会遇到的缓存问题。 项目打包后生成的模板文件如下：12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=utf-8&gt; &lt;title&gt;移山&lt;/title&gt; &lt;link rel=icon href=/static/assets/favicon.ico type=image/x-icon&gt; &lt;link href=/static/css/app.37f937e3e08602bbb89778796e294cf1.css rel=stylesheet&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=app&gt;&lt;/div&gt;&lt;script type=text/javascript src=/static/js/manifest.2ae2e69a05c33dfc65f8.js&gt;&lt;/script&gt;&lt;script type=text/javascript src=/static/js/vendor.d903c30c8b95cb48653b.js&gt;&lt;/script&gt;&lt;script type=text/javascript src=/static/js/app.0c675ae0a3c300e0af57.js&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二.什么是plugin plugin是一个具有 apply方法的 js对象。 apply方法会被 webpack的 compiler（编译器）对象调用，并且 compiler 对象可在整个 compilation（编译）生命周期内访问。 一个plugin看起来大概是这个样子： 1234567891011function CustomPlugin(options)&#123; // options是配置文件，你可以在这里进行一些与options相关的工作&#125;// 每个plugin都必须定义一个apply方法，webpack会自动调用这个方法CustomPlugin.prototype.apply = function(compiler)&#123; ...... &#125;);&#125;module.exports = CustomPlugin; 有兴趣对自定义插件感兴趣，想了解的更多的，可以看这里。 三.使用plugin在 webpack 配置文件（webpack.config.js）中，向 plugins 属性传入 new 实例即可。比如： 1234567891011121314151617const HtmlWebpackPlugin = require('html-webpack-plugin');const webpack = require('webpack');module.exports = &#123; module: &#123; loaders: [ &#123; test: /\.(js|jsx)$/, loader: 'babel-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), //访问内置的插件 new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) //访问第三方插件 ]&#125;; 注意 webpack中的插件分为内置插件和第三方插件 内置插件不需要额外安装依赖，如上面的例子中：UglifyJsPlugin插件 如果是第三方插件，如上面的例子中HtmlWebpackPlugin插件，则使用之前需要进行安装：1npm install html-webpack-plugin --save-dev 四.案例在对plugin有了一个基本认识后，来做一个小案例： “我想对所有的文件打包后添加一个版权声明” 目录结构webpackPluginDemo的目录结构如下：├── app├── package-lock.json├── package.json├── src│ └── index.js└── webpack.config.js 1. 安装webpack在webpackPluginDemo根目录下安装webpack:1npm install --save-dev webpack 2.入口文件index.js1document.write('webpack系列之plugin的基本使用！'); 3.webpack配置文件webpack.config.js1234567891011const webpack = require('webpack')module.exports = &#123; entry: __dirname + "/src/index.js", //入口文件 output: &#123; path: __dirname + "/app", //打包后的文件存放的地方 filename: "bundle.js" //打包后输出文件的文件名 &#125;, plugins: [ new webpack.BannerPlugin('版权所有，翻版必究') ],&#125; 注意：BannerPlugin为内置插件，如果是其它的外置插件，则需在使用前要先安装。 4.执行打包命令1234567➜ webpackPluginDemo webpackHash: 16453f43abe665633286Version: webpack 2.4.1Time: 70ms Asset Size Chunks Chunk Namesbundle.js 2.86 kB 0 [emitted] main [0] ./src/index.js 210 bytes &#123;0&#125; [built] 5.查看结果打包成功，可以看到app目录下面已经生成了bundle.js，打开bundle.js会发现版权信息已经加上了： 五.常用插件常用插件 BannerPlugin：对所有的文件打包后添加一个版权声明 uglifyjs-webpack-plugin： 对JS进行压缩混淆 HtmlWebpackPlugin：可以根据模板自动生成html代码，并自动引用css和js文件 Hot Module Replacement：在每次修改代码保存后，浏览器会自动刷新，实时预览修改后的效果 copy-webpack-plugin：通过Webpack来拷贝文件 extract-text-webpack-plugin：将js文件和css文件分别单独打包，不混在一个文件中 DefinePlugin 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的变量时非常有用 optimize-css-assets-webpack-plugin 不同组件中重复的css可以快速去重 更多可点击这里查看。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack系列之loader的基本使用]]></title>
      <url>%2F2018%2F04%2F16%2Fwebpack-loader%2F</url>
      <content type="text"><![CDATA[webpack系列之loader及简单的使用一. loader有什么用 webpack本身只能打包Javascript文件，对于其他资源例如 css，图片，或者其他的语法集比如jsx，是没有办法加载的。 这就需要对应的loader将资源转化，加载进来。 比如你的工程中，样式文件都使用了less语法，是不能被浏览器识别的，这时候我们就需要使用对应的loader，来把less语法转换成浏览器可以识别的css语法。 例如一个简单的less文件：转换前：12345678910.demo &#123; width: 200px; height: 100px; margin: auto; border: 1px solid; p &#123; font-weight:bold; padding-left: 30px; &#125;&#125; 转换后：1234567891011.demo &#123; width: 200px; height: 100px; margin: auto; border: 1px solid;&#125;.demo p &#123; font-weight: bold; padding-left: 30px;&#125; 后面的案例也是拿这个less文件来做演示的。 二. loader是什么先来看一下官方对loader的一个解释： A loader is a node module exporting a function 翻译过来：loader就是一个export出来的function。 既然是 node module，所以如果你自己要自定义一个loader，完全可以这么写：123module.exports = function (source) &#123; // todo&#125; 解释 其中source参数是这个loader 要处理的源文件的字符串 返回经过“翻译”后的webpack 能够处理的有效模块 如果你所写的 loader 需要依赖其他模块的话，那么同样以 module 的写法，将依赖放在文件的顶部引进来即可：1234var fs = require("fs")module.exports = function (source) &#123; // todo&#125; 如果你希望将处理后的结果（不止一个）返回给下一个 loader，那么就需要调用 webpack 所提供的 API。 由于本篇我们只讲loader的基本使用，故这里不再深入讲解，有兴趣的可以点击这里学习。 三. 使用loader在看了前面的介绍后，接下来给大家介绍一下怎么使用loader。 使用loader的方式有三种使用方式，如下： 配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 CLI：在 shell 命令中指定它们。 以上三种方式，我们在开发过程中推荐使用第一种方式： 比如你想使用webpack来打包样式文件，则可以在webpack.config.js里添加如下代码：12345678module: &#123; rules: [ &#123; test: /\.css$/, // 正则匹配所有.css后缀的样式文件 use: ['style-loader', 'css-loader'] // 使用这两个loader来加载样式文件 &#125; ]&#125; module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。 上述rules的作用：webpack在打包过程中，凡是遇到后缀为css的文件，就会使用style-loader和css-loader去加载这个文件。 四.案例在对loader有了一个大概的认识后，来做一个小案例，需求如下： 将上一篇（webpack系列之基本概念和使用）的demo输出文字居中并用黑框圈起来 目录结构代码目录结构如下：├── node_modules├── app│ ├── bundle.js│ └── index.html├── package-lock.json├── package.json├── src│ ├── index.js│ └── main.less└── webpack.config.js 1. 安装loader我们必须使用 loader 告诉 webpack 加载 less 文件，为此，需要首先安装相对应的 loader： 1234npm install --save-dev lessnpm install --save-dev less-loadernpm install --save-dev css-loadernpm install --save-dev style-loader 这些loader的作用如下： 安装less-loader后可以在js中使用require的方式来加载less文件了； 安装css-loader后可以在js中加载css文件； 安装style-loader的目的是为了让加载的css作为style标签内容插入到html中。 2. 配置loaderwebpack.config.js代码如下： 12345678910111213141516module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + "/src/index.js", //入口文件 output: &#123; path: __dirname + "/app", //打包后的文件存放的地方 filename: "bundle.js" //打包后输出文件的文件名 &#125;, module: &#123; rules: [ &#123; test: /\.less$/, use: ['style-loader','css-loader', 'less-loader'] &#125; ] &#125;&#125; 3.新建样式文件main.less代码如下：12345678910.demo &#123; width: 200px; height: 100px; margin: auto; border: 1px solid; p &#123; font-weight:bold; padding-left: 30px; &#125;&#125; 4. 修改入口文件在入口文件index.js里引入我们的样式文件1234567require ('./main.less');var element = document.createElement('div');element.className = 'demo';var p = document.createElement('p');p.innerText = 'webpack系列之loader的基本使用！';element.appendChild(p);document.body.appendChild(element); 5.打包在项目根目录（webpack-demo）下执行打包命令： 1➜ webpack-demo webpack 打包成功，会输出如下：12345678Hash: 1bb51c6a348686a223dbVersion: webpack 3.10.0Time: 1077ms Asset Size Chunks Chunk Namesbundle.js 53.8 kB 0 [emitted] main [0] ./src/index.js 273 bytes &#123;0&#125; [built] [1] ./src/main.less 1.19 kB &#123;0&#125; [built] [2] ./node_modules/css-loader!./node_modules/less-loader/dist/cjs.js!./src/main.less 304 bytes &#123;0&#125; [built] 6. 查看结果在浏览器里刷新index.html：你会发现输出的文字被一个黑框给圈了起来，并且加粗显示，这就表明我们的样式文件已经生效了，而且从截图当中也可以看见样式文件也插入到了html中。 五.常用loader样式 css-loader : 解析css文件中代码 style-loader : 将css模块作为样式导出到DOM中 less-loader : 加载和转义less文件 sass-loader : 加载和转义sass/scss文件 脚本转换编译 script-loader : 在全局上下文中执行一次javascript文件，不需要解析 babel-loader : 加载ES6 代码后使用Babel转义为ES5后浏览器才能解析 Files文件 url-loader : 多数用于加载图片资源,超过文件大小显示则返回data URL raw-loader : 加载文件原始内容(utf-8格式) 加载框架 vue-loader : 加载和转义vue组件 react-hot-loader : 动态刷新和转义react组件中修改的部分 六. 总结本篇向大家介绍了loader有什么用，什么是loader，以及怎么使用loader这些基础知识，如果有兴趣想了解得更深入一些，可以看看怎么编写一个loader。下一篇会给大家介绍：webpack系列之Plugin及简单的使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack系列之基本概念和使用]]></title>
      <url>%2F2018%2F03%2F15%2Fwebpack-first%2F</url>
      <content type="text"><![CDATA[webpack系列之基本概念和使用前言最近在做vue项目，自然而然就接触到了webpack这个打包工具，借此把一些总结分享出来。webpack知识点比较多，打算做为一个系列分篇讲解，今天先分享第一篇：webpack系列之基本概念和使用。 一. 什么是webpackwebpack可以看做是模块打包工具：它将各种静态资源（比如：JavaScript 文件，图片文件，样式文件等）视为模块，它能够对这些模块进行解析优化和转换等操作，最后将它们打包在一起，打包后的文件可用于在浏览器中使用。 下面看一个图能够很清晰的展现这个打包流程： 二. 为什么使用webpack先举一个大家都很熟悉的例子： 一台计算机内部需要很多很多根线来连接单元器件，假如每条线不按规则摆放，将要占用极大的空间，且不好管理。幸好人们发明了集成电路，才有了现代计算机的板卡。 大家看，通过这个板卡，所有的元器件，电线都按规则摆放，规整有序，很大的节省了空间，而且也很方便管理。 你可以把webpack看做是这个板卡，项目中的各种各样的JavaScript程序和依赖包可以看成是计算机内部需要的很多根线和单元器件，webpack通过loader将这些JavaScript程序和依赖包都转换成JavaScript 模块，就好比我们将单元器件和线按照一定的规则摆放，放在固定的位置方便管理，这样通过webpack我们就把一个项目中的复杂程序细化为了各种具有依赖关系的模块，从而使我们的项目管理起来更加方便。 webpack优势 webpack能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等，而且还具有以下几点优势： webpack 是以 commonJS 的形式来书写脚本的，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移 能被模块化的不仅仅是 JS 了 扩展性强，具有强大的插件（Plugin）接口，使用起来比较灵活，特别是支持热插拔的功能很实用 可以将代码切割成不同的块（chunk），每个块包含一个或多个模块，块可以按需被异步加载，降低了初始化时间 …… 三. 基本概念在正式讲解怎么使用webpack之前，你需要先理解四个核心概念： 入口(entry) 输出(output) loader 插件(plugins) 本篇做为一个开门篇，先讲解前两个核心概念：入口(entry)和输出(output)。 3.1 入口(entry)入口起点(entry point)指示 webpack 应该使用哪个模块做为入口文件，来作为构建其内部依赖图的开始。进去入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的，每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。 3.2 出口(output)output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，这些都可以在webpack的配置文件中指定，后面的案例会给大家介绍怎么去配置。 四.案例在讲了webpack是什么，为什么使用webpack，以及两个核心概念后，我们来做一个小案例来真实感受一下。 4.1 基本安装我们创建一个目录，初始化npm，并且在本地使用npm安装webpack 123mkdir webpack-demo &amp;&amp; cd webpack-demonpm initnpm install --save-dev webpack 4.2 目录结构1234567├── node_modules├── dist│ └── index.html├── package-lock.json├── package.json└── src └── index.js 4.3 修改入口文件 打开src\index.js，添加如下代码：123var element = document.createElement('div');element.innerHTML = 'webpack demo！';document.body.appendChild(element); 4.4 执行打包命令1234567➜ webpack-demo webpack src/index.js dist/bundle.jsHash: 2432d7e2ecc1d3cb0c5bVersion: webpack 3.10.0Time: 63ms Asset Size Chunks Chunk Namesbundle.js 2.65 kB 0 [emitted] main [0] ./src/index.js 179 bytes &#123;0&#125; [built] 打开dist目录，你会发现打包后的文件bundle.js已经生成。 4.5 引入bundle.js 打开dist\index.html添加如下代码：12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;webpack练习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.6 效果直接浏览器打开 index.html： 4.7 使用配置文件可能大家看到打包命令后会有疑问： 这个打包命令有点长，这样岂不是很容易出错? 的确，webpack有许多比较高级的功能都可以通过命令行模式去实现，但是这样很不方便，且容易出错，更好的办法就是定义个配置文件，我们可以把所有的与打包相关的信息放在里面。 这比在终端(terminal)中输入大量命令要高效的多。 那该怎么做呢？ 我们新建一个webpack配置文件：webpack.config.js:12345678module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + "/src/index.js", //入口文件 output: &#123; path: __dirname + "/dist", //打包后的文件存放的地方 filename: "bundle.js" //打包后输出文件的文件名 &#125;&#125; 命令行执行只需要：webpack即可实现打包：1234567➜ webpack-demo webpackHash: 37ae154d97c486e04d87Version: webpack 3.10.0Time: 73ms Asset Size Chunks Chunk Namesbundle.js 3.4 kB 0 [emitted] main [0] ./src/index.js 179 bytes &#123;0&#125; [built] 这条命令会自动引用webpack.config.js文件中的配置选项进行打包，再次访问index.html，会发现第一种打包方式后输出同样的结果，但是简化了命令，也降低了因命令行过长而导致的错误。 注意： webpack.config.js是webpack默认的配置文件名，如果我们的配置文件不叫这个名字时，我们需要借助一个 --config 参数来实现打包（--config 参数来指定去找哪个配置文件）：1webpack --config `webpack.filename.js` 五.总结第一篇先讲解一下webpack的基本概念，以及通过一个小案例让大家感受一下webpack的简单使用，下一篇会深入一些，讲解webpack中的另一个重要概念：Loader。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手把手教你怎么使用Vuex系列之开发计数器]]></title>
      <url>%2F2017%2F08%2F21%2Fvuex-step-counter3%2F</url>
      <content type="text"><![CDATA[手把手教你怎么使用Vuex系列之开发计数器创建项目我们先使用vue-cli创建一个基于webpack的项目。1234567vue init webpack vuex-step-demo# 安装依赖......cd vuex-step-demonpm installnpm run dev 访问 localhost:8080，会显示如下的页面: 来看一下使用Vue命令行工具（vue-cli）创建的应用的目录结构： 新建Store在src目录下面新建store目录，store下新建store.js，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = &#123; count: 0&#125;const mutations = &#123; increment (state) &#123; state.count++ &#125;, decrement (state) &#123; state.count-- &#125;&#125;const actions = &#123; increment: (&#123; commit &#125;) =&gt; commit('increment'), decrement: (&#123; commit &#125;) =&gt; commit('decrement'), incrementIfOdd (&#123; commit, state &#125;) &#123; if ((state.count + 1) % 2 === 0) &#123; commit('increment') &#125; &#125;, incrementAsync (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('increment') resolve() &#125;, 1000) &#125;) &#125;&#125;const getters = &#123; evenOrOdd: state =&gt; state.count % 2 === 0 ? 'even' : 'odd'&#125;export default new Vuex.Store(&#123; state, getters, actions, mutations&#125;) 展示计数器页面的组件Counter.vue：12345678910&lt;template&gt; &lt;div id="app"&gt; Clicked: &#123;&#123; $store.state.count &#125;&#125; times, count is &#123;&#123; evenOrOdd &#125;&#125;. &lt;button @click="increment"&gt;+&lt;/button&gt; &lt;button @click="decrement"&gt;-&lt;/button&gt; &lt;button @click="incrementIfOdd"&gt;Increment if odd&lt;/button&gt; &lt;button @click="incrementAsync"&gt;Increment async&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; js代码如下：1234567891011121314import &#123; mapGetters, mapActions &#125; from 'vuex'export default &#123; computed: mapGetters([ 'evenOrOdd', 'recentHistory' ]), methods: mapActions([ 'increment', 'decrement', 'incrementIfOdd', 'incrementAsync' ])&#125; 在路由里添加 计数器的路由：router/index.js：12345678910111213141516171819202122import Vue from 'vue'import Router from 'vue-router'import Hello from '@/components/Hello'import Counter from '@/components/Counter'import App from '@/components/shopping-cart/App'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'Hello', component: Hello &#125;, &#123; path: '/counter', name: 'Counter', component: Counter &#125; ]&#125;) 在main.js里引入store123456789import store from './store/store'new Vue(&#123; el: '#app', router, store, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 访问：http://localhost:8080/#/counter，回车则显示如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手把手教你怎么使用Vuex-Vuex系列之Vuex核心介绍]]></title>
      <url>%2F2017%2F08%2F20%2Fvuex-step-counter2%2F</url>
      <content type="text"><![CDATA[手把手教你怎么使用Vuex之Vuex核心介绍 通过上一篇大概了解了Vuex是什么，这一篇来大概讲解一下Vuex的核心部分。 一.开始 每一个 Vuex 应用的核心就是 store（仓库）。”store” 基本上就是一个容器，它包含着你的应用中大部分的状态(state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 二.Store安装完Vuex之后，让我们创建一个Store。 1234567891011121314151617import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; &#125;, actions: &#123; &#125;, mutations: &#123; &#125;, getters: &#123; &#125;, modules: &#123; &#125;&#125;)export default store 上述代码就包含了定义Vuex Store时的5个关键属性，也就是我们这一篇文章要讲的核心介绍。 三.State在Vue组件中如果想要获取Vuex的状态，都需要从state中获取。最简单的方式就是在计算属性中返回state的某个状态：12345678910111213141516// 创建一个 Storeconst store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;&#125;)// 创建一个 Counter 组件const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return store.state.count &#125; &#125;&#125; 如果你想在每个子组件中都调用state，可以在根组件中注册store选项，vuex就会提供了一种机制将状态从根组件『注入』到每一个子组件中（需调用 Vue.use(Vuex)） store/index.js:1234567891011import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; ... &#125; ...&#125;)export default store 根组件：123456import store from './store'const app = new Vue(&#123; // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store&#125;); 子组件：12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; 在Vuex 2中新增了一个mapState辅助函数，当一个组件需要获取多个状态时，可以直接在函数中声明。子组件：1234567891011121314151617import &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125; 当计算属性与子节点相同时，可以怎么写：1234computed: mapState([ // 映射 this.count 为 store.state.count 'count']) 四.Getters当state中的某些状态在各个组件中都被频繁使用，如果在每个组件中都声明一次，将会变得非常繁琐。因此便有了getters来帮助我们解决这个问题，你也可以把它看做Vuex的计算属性或者理解为定义一个别名使我们能够在组件中方便的调用。 场景：比如计算器案例中我们需要判断当前的计数是奇数还是偶数，并在页面上显示出来。我们可以这样做： 创建evenOrOdd变量在getter.js里创建一个 evenOrOdd变量，判断是奇数还是偶数1export const evenOrOdd = state =&gt; state.count % 2 === 0 ? 'even' : 'odd' 使用evenOrOdd变量然后在计算器项目中的任何一个页面上显示 当前计数是奇数还是偶数。在Vuex 2中提供了一个mapGetters辅助函数用于有多个状态需要获取的情况。123456789101112131415&lt;template&gt; &lt;div id="app"&gt; Clicked: &#123;&#123; $store.state.count &#125;&#125; times, count is &#123;&#123; evenOrOdd &#125;&#125;. --- &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters, mapActions &#125; from 'vuex' export default &#123; computed : mappGetters([ 'evenOrOdd' ]) &#125;&lt;/script&gt; 在counter.vue组件里这样使用即可。 五.Mutations更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。mutation不能直接调用，而要通过相应的 type 调用相应的store.commit方法：1store.commit('increment') Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数。我们可以向store.commit传入额外的参数payload，payload可以是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读。 1234567// ...mutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125;store.commit('increment', 10) 使用常量替代 Mutation 事件类型使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：123456789101112131415// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION'// store.jsimport Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-types'const store = new Vuex.Store(&#123; state: &#123; ... &#125;, mutations: &#123; // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) &#123; // mutate state &#125; &#125;&#125;) 说明：用不用常量取决于你 —— 在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。 在组件中提交 Mutations你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。12345678910111213import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment' // 映射 this.increment() 为 this.$store.commit('increment') ]), ...mapMutations(&#123; add: 'increment' // 映射 this.add() 为 this.$store.commit('increment') &#125;) &#125;&#125; 每当你需要管理状态时，每个改变都可以定义成一个命令，叫Mutation，通过在store中定义命令和执行器，要改变状态就通过store发出这个命令。 Mutation强调同步操作，至于你要对管理状态作出异步的操作就得看看Action 六.ActionAction相对于mutation，有以下不同： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 在组件中vuex配置相关action,方法的实现通常是在异步操作中组合一些mutation，当然，如果Action用在同步场景，你可以把Action理解成用于组合Mutation的大Mutation，另外 ，action方法的第一个参数总是store。 1234567// 定义Actionsconst actions = &#123; actionName(&#123; commit &#125;) &#123; //dosomething commit('mutationName') &#125;&#125; 在组件中使用12345678import &#123;mapActions&#125; from 'vuex'//我是一个组件export default &#123; methods: mapActions([ 'actionName', ])&#125; 简单同步操作用Mutation还是Action？从语法来说，你喜欢哪个都行，不过统一开发思路，在组件内，只跟action打交道，然后action里面再去转发Mutation，这样开发体验统一，你无须访问store，好维护。官方指定的规则也是只用action。 七.Modules如果应用简单，mutation、action、state各自定义一个总文件，如果多模块，那么在每个模块定义各自的这三个部分，借助vuex store的modules配置即可。 结束关于Vuex的核心概念已经介绍得差不多了，下一篇就进入撸码阶段，会一步一步的介绍怎么使用Vuex去开发一个计数器的demo。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手把手教你怎么使用Vuex系列一]]></title>
      <url>%2F2017%2F08%2F17%2Fvuex-step-counter%2F</url>
      <content type="text"><![CDATA[手把手教你怎么使用Vuex系列一什么是Vuex来看一下官方的定义： Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 Vuex解释在Vue中，多组件的开发给我们带来了很多的方便，但同时当项目规模变大的时候，多个组件间的数据通信和状态管理就显得难以维护。而Vuex就此应运而生。将状态管理单独拎出来，应用统一的方式进行处理，在后期维护的过程中数据的修改和维护就变得简单而清晰了。 单向数据流Vuex采用和Redux类似的单向数据流的方式来管理数据：用户界面负责触发动作（Action)进而改变对应状态（State），从而反映到视图（View）上。如下图所示： 但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏： 多个视图依赖于同一状态。 来自不同视图的行为需要变更同一状态。 对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！ 另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。 这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。 Mutations更改Vuex的store中的状态的唯一方法是提交mutation。它本质就是用来处理数据的函数。 创建项目我们先使用vue-cli创建一个基于webpack的项目。1234567vue init webpack vuex-step-demo# 安装依赖......cd vuex-step-demonpm installnpm run dev 访问 localhost:8080，会显示如下的页面: 未完待续概念性的文字说的太多容易晕，下一篇我会一步一步的详细给大家讲解怎么使用Vuex去开发一个简单的计数器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React之渲染元素]]></title>
      <url>%2F2017%2F05%2F20%2Freact-rendering-elements%2F</url>
      <content type="text"><![CDATA[React-渲染元素开场白 接着上一节JSX的讲解后：我们大概清楚了以下几个事儿: 知道JSX是个什么东东 为什么React要推荐使用JSX 以及JSX的一些基本语法。 本篇文章谈一下React是怎么渲染元素的。 元素元素是React应用中的最小部件，正是由一个或多个元素构建出来了组件。一个元素用于描述你将在屏幕上看到的内容，比如：1const element = &lt;h1&gt;Hello, world&lt;/h1&gt;; 渲染元素到DOM根DOM节点假设我们的HTML文件中有这样的一个&lt;div&gt;:1&lt;div id="root"&gt;&lt;/div&gt; 我们称这是一个根DOM节点，该节点内的所有内容都是有React DOM管理 注意 一个用React构建的应用程序通常只有一个根DOM节点。 但是如果把这些应用程序整合到现有的app当中去，那么该app中就可能会包含多个相互独立的根DOM节点。 更新已渲染的元素React元素是不可变的，一旦你创建了一个元素，就不能再修改其子元素或任何属性。更新UI的唯一方法是创建一个新的元素，并将其传入到ReactDOM.render()方法。来思考下时钟的例子,完整代码如下：1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;rendering-elements&lt;/title&gt; &lt;script src="../build/react.js"&gt;&lt;/script&gt; &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt; &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt; &lt;script src="../build/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/babel"&gt; function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello,world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById('root') ) &#125; setInterval(tick,1000); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="root"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 以上代码，每隔1秒，就会通过setInterval()回调ReactDOM.render()方法来重新渲染元素。 注意: 实际上，大多数 React 应用只会调用 ReactDOM.render() 一次。在接下来的章节中，我们将学习如何将这些代码封装到有状态的组件中。 React 只更新必需要更新的部分React DOM 会将元素及其子元素与之前版本逐一对比, 并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态。我们对 上一个例子 进行检查来验证这一点:即使我们每隔1秒都重建了整个元素, 但实际上 React DOM 只更新了修改过的文本节点。 本文做为自己加强记忆之篇，均参考自：http://www.css88.com/react/docs/rendering-elements.html，在此列出，大家共同学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[说说对JSX的认识]]></title>
      <url>%2F2017%2F05%2F06%2Freact-jsx%2F</url>
      <content type="text"><![CDATA[引子 最近几个月做的一个项目，使用了react技术体系，自然而然的用到了JSX。下面就总结一下自己对JSX的认识。 什么是JSX 即JavaScript XML，一种在React组建内部构建标签的类XML语法。（增强React程序组件的可读性） JSX可以看作JavaScript的拓展，看起来有点像XML。使用React，可以进行JSX语法到JavaScript的转换。 下面我们来看一下一个简单的例子。考虑一下这个变量的声明：1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 这个标签语法既不是字符串也不是HTML，这就是JSX。它是JavaScript的一种扩展语法。 JSX小例子我们先从官网的一个最简单的例子说起，为了让大家能够直接在本地运行，我贴出了完整的代码如下：1234567891011121314151617181920&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Hello React!&lt;/title&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.4.2/react.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.4.2/react-dom.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.24/browser.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; ReactDOM.render( element, document.getElementById('example') ); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 大家可以直接粘贴上面代码，保存在本地的一个test.html文件里，双击打开后，在浏览器里输出: 我们看到1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; element变量的声明就是用了JSX语法，HTML语言直接写在JavaScript语言之中，不加任何引号。 注意: script 标签的 type 属性为 text/babel，这是React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是在页面中直接使用 JSX 的地方，都要加上 type=&quot;text/babel&quot;。 一共用了三个库： react.js 、react-dom.js 和 browser.min.js ，它们必须首先加载。其中，react.js 是 React 的核心库，react-dom.js 是提供与 DOM 相关的功能， browser.min.js的作用是将 JSX 语法转为 JavaScript 语法。 js构造dom比如要创建一个dom超链接：1&lt;a class="link" href="https://github.com/facebook/react"&gt;React&lt;a&gt; 我们在原生DOM中，用js构造dom的方式是这样的：1234var a = document.createElement('a')a.setAttribute('class', 'link')a.setAttribute('href', 'https://github.com/facebook/react')a.appendChild(document.createTextNode('React')) 这个代码应该是大家比较熟悉的。当你在写代码的时候会不会感觉很繁琐呢，我们可以封装一下：12345678//第一个参数为node名//第二个参数为一个对象，dom属性与事件都以键值对的形式书写//第三个到第n个为子node，它们将按参数顺序出现，//在这个例子中只有一个子元素，而且也是文本元素，所以可以直接书写，否则还得React.createElement一下var a = React.createElement('a', &#123; className: 'link', href: 'https://github.com/facebook/react'&#125;, 'React') 看完这个代码，是不是感觉一下子要简洁的多。现在有个编译工具，可以让你用html语法来写React.createElement，部署上线前编译回来。你愿意吗？不管你的答案是什么，但这就是jsx的一半真相。 来看个直接的对比前面已经回答过，在使用React的时候，可以不使用JSX,大概这样写：123var child1 = React.createElement('li', null, 'First Text Content');var child2 = React.createElement('li', null, 'Second Text Content');var root = React.createElement('ul', &#123; className: 'my-list' &#125;, child1, child2); 使用这样的机制，我们完全可以用JavaScript构建完整的界面DOM树，正如我们可以用JavaScript创建真实DOM。但这样的代码可读性并不好，于是React发明了JSX，利用我们熟悉的HTML语法来创建虚拟DOM：123456var root =( &lt;ul className="my-list"&gt; &lt;li&gt;First Text Content&lt;/li&gt; &lt;li&gt;Second Text Content&lt;/li&gt; &lt;/ul&gt;); 总结 这两段代码是完全等价的，后者将XML语法直接加入到JavaScript代码中，让你能够高效的通过代码而不是模板来定义界面。 之后JSX通过翻译器转换到纯JavaScript再由浏览器执行。 注意 在实际开发中，JSX在产品打包阶段都已经编译成纯JavaScript，JSX的语法不会带来任何性能影响。另外，由于JSX只是一种语法，因此JavaScript的关键字class, for等也不能出现在XML中，而要如例子中所示，使用className, htmlFor代替，这和原生DOM在JavaScript中的创建也是一致的。 相信大家在看完了上面的这些举例后，心中的疑问自然而然就迎刃而解了。 因此，JSX本身并不是什么高深的技术，可以说只是一个比较高级但很直观的语法糖。它非常有用，却不是一个必需品，没有JSX的React也可以正常工作：只要你乐意用JavaScript代码去创建这些虚拟DOM元素。 为什么使用JSX抛出疑问看了上面的这些简单的demo，大家肯定会抛出这样的疑问： 为什么React官方推荐使用JSX呢？ 等等。。。 使用React，不一定非要使用JSX语法，可以使用原生的JS进行开发。但是React作者强烈建议我们使用JSX，因为： JSX在定义类似HTML这种树形结构时，十分的简单明了。 简明的代码结构更利于开发和维护。 XML有着开闭标签，在构建复杂的树形结构时，比函数调用和对象字面量更易读。 可能说这些你会感觉比较模糊，下面来举几个看得见的例子。 前端界面的最基本功能在于展现数据，为此大多数框架都使用了模板引擎， 在AngularJS中：123456&lt;div ng-if="person != null"&gt; Welcome back, &lt;b&gt;&#123;&#123;person.firstName&#125;&#125; &#123;&#123;person.lastName&#125;&#125;&lt;/b&gt;!&lt;/div&gt;&lt;div ng-if="person == null"&gt; Please log in.&lt;/div&gt; 在EmberJS中：12345&#123;&#123;#if person&#125;&#125; Welcome back, &lt;b&gt;&#123;&#123;person.firstName&#125;&#125; &#123;&#123;person.lastName&#125;&#125;&lt;/b&gt;!&#123;&#123;else&#125;&#125; Please log in.&#123;&#123;/if&#125;&#125; 总结 模板可以直观的定义UI来展现Model中的数据，你不必手动的去拼出一个很长的HTML字符串，几乎每种框架都有自己的模板引擎。 传统MVC框架强调界面展示逻辑和业务逻辑的分离，因此为了应对复杂的展示逻辑需求，这些模板引擎几乎都不可避免的需要发展成一门独立的语言。 如上面代码所示，每个框架都有自己的模板语言语法。而这无疑增加了框架的门槛和复杂度。 使用JSX正因为如此，React直接放弃了模板而发明了JSX。看上去很像模板语言，但其本质是通过代码来构建界面，这使得我们不再需要掌握一门新的语言就可以直观的去定义用户界面：掌握了JavaScript就已经掌握了JSX。 这里不妨再引用之前文章举过的例子，在展示一个列表时，模板语言通常提供名为Repeat的语法，例如在Angular中：123456&lt;ul class="unstyled"&gt; &lt;li ng-repeat="todo in todoList.todos"&gt; &lt;input type="checkbox" ng-model="todo.done"&gt; &lt;span class="done-&#123;&#123;todo.done&#125;&#125;"&gt;&#123;&#123;todo.text&#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; 而使用JSX，则代码如下：1234567891011121314var lis = this.todoList.todos.map(function (todo) &#123; return ( &lt;li&gt; &lt;input type="checkbox" checked=&#123;todo.done&#125;&gt; &lt;span className=&#123;'done-' + todo.done&#125;&gt;&#123;todo.text&#125;&lt;/span&gt; &lt;/li&gt; );&#125;);var ul = ( &lt;ul class="unstyled"&gt; &#123;lis&#125; &lt;/ul&gt;); 可以看到，JSX完美利用了JavaScript自带的语法和特性，我们只要记住HTML只是代码创建DOM的一种语法形式，就很容易理解JSX。而这种使用代码构建界面的方式，完全消除了业务逻辑和界面元素之间的隔阂，让代码更加直观和易于维护。 JSX的语法你可以用 花括号 把任意的 JavaScript 表达式 嵌入到 JSX 中。例如，2 + 2， user.firstName， 和 formatName(user)，这些都是可用的表达式。12345678910111213141516171819function formatName(user) &#123; return user.firstName + ' ' + user.lastName;&#125;const user = &#123; firstName: 'Harper', lastName: 'Perez'&#125;;const element = ( &lt;h1&gt; Hello, &#123;formatName(user)&#125;! &lt;/h1&gt;);ReactDOM.render( element, document.getElementById('root')); JSX 也是一个表达式编译之后，JSX 表达式就变成了常规的 JavaScript 对象。 这意味着你可以在 if 语句或者是 for 循环中使用 JSX，用它给变量赋值，当做参数接收，或者作为函数的返回值。123456function getGreeting(user) &#123; if (user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;; &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;&#125; 用 JSX 指定属性值您可以使用双引号来指定字符串字面量作为属性值：1const element = &lt;div tabIndex="0"&gt;&lt;/div&gt;; 您也可以用花括号嵌入一个 JavaScript 表达式作为属性值:1const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;; 注意 在属性中嵌入 JavaScript 表达式时，不要使用引号来包裹大括号。否则，JSX 将该属性视为字符串字面量而不是表达式。对于字符串值你应该使用引号，对于表达式你应该使用大括号，但两者不能同时用于同一属性。 用 JSX 指定子元素如果是空标签，您应该像 XML 一样，使用 /&gt;立即闭合它：1const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;; JSX 标签可能包含子元素：123456const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt; &lt;/div&gt;); JSX 防止注入攻击在JSX中嵌入用户输入是安全的：123const title = response.potentiallyMaliciousInput;// This is safe:const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;; 默认情况下， 在渲染之前, React DOM 会格式化(escapes) JSX中的所有值。从而保证用户无法注入任何应用之外的代码。在被渲染之前，所有的数据都被转义成为了字符串处理。 以避免 XSS(跨站脚本) 攻击。 JSX 表示对象Babel 将JSX编译成 React.createElement() 调用。 下面的两个例子是是完全相同的：12345const element = ( &lt;h1 className="greeting"&gt; Hello, world! &lt;/h1&gt;); 12345const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!'); React.createElement() 会执行一些检查来帮助你编写没有bug的代码，但基本上它会创建一个如下所示的对象：12345678// 注意: 这是简化的结构const element = &#123; type: 'h1', props: &#123; className: 'greeting', children: 'Hello, world' &#125;&#125;; 结尾关于JSX的介绍大概讲到这里，看完这篇文章后，希望大家能能够了解什么是JSX,React为什么推荐使用JSX等问题。在下一节中来探索如何将 React 元素渲染到 DOM 上。 参考链接 https://facebook.github.io/react/docs/introducing-jsx.html http://www.css88.com/react/docs/introducing-jsx.html http://www.infoq.com/cn/articles/react-jsx-and-component]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手把手教你开发nodejs微博网站-用户注册篇]]></title>
      <url>%2F2017%2F02%2F07%2FnodejsBlog-reg%2F</url>
      <content type="text"><![CDATA[引子 上一篇主要讲解了本项目开发使用的数据库MongoDb,MongoDB 的可视化管理工具Robomongo，MongoDB 的驱动库Mongolass,已经具备了功能开发的基本条件。 本篇我主要讲解用户注册功能的开发。 目录结构在正式开发之前，我们先来看一下项目的目录结构,如下: 目录说明对应的主要文件及文件夹用处如下说明： app.js: 程序主文件 models: 存放操作数据库的文件 package.json: 存储项目名称、描述信息、作者、依赖等等信息 public: 存放静态文件，如样式、图片等 routes: 存放路由文件 views: 存放模板文件 Tip 我们遵循了MVC的开发模式: 控制器(Controller)，一组行为的集合 模型(Model),数据相关的操作和封装 视图(View),视图的渲染对MVC不太熟悉的童鞋可以自行查找一下资料，我这里不再赘述了。配置文件 不管是大型项目，还是小型项目，将配置文件与代码分离开来都是一个比较好的做法。 我们通常将配置写到一个配置文件里，如 config.js 或 config.json ，并放到项目的根目录下。 但通常我们都会有许多环境，如本地开发环境、测试环境和线上环境等，不同的环境的配置不同，我们不可能每次部署时都要去修改引用 config.test.js 或者 config.production.js。 config-lite config-lite 模块正是你需要的。关于config-lite的介绍和使用可以点这里: config-lite 。 config-lite 会根据环境变量（NODE_ENV）的不同从当前执行进程目录下的 config 目录加载不同的配置文件。如果不设置 NODE_ENV，则读取默认的 default 配置文件，如果设置了 NODE_ENV，则会合并指定的配置文件和 default 配置文件作为配置，config-lite 支持 .js、.json、.node、.yml、.yaml 后缀的文件。 安装config-lite 1npm i config-lite --save 即可。 建配置文件 在根目录下面，新建config/default.js文件,代码如下： 123456789module.exports = &#123; port : 3000, session : &#123; secret: 'myblog', key: 'myblog', maxAge: 2592000000 &#125;, mongodb: 'mongodb://localhost:27017/myblog'&#125;; 参数解释： port： 程序启动时要监听的端口号 session：express-session 的配置信息，后面会介绍 mongodb：mongodb 的地址，myblog 为 db 名 express-session由于 HTTP 协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识别具体的用户，这个机制就是会话（Session）。关于会话(Session)的介绍在网上有比较多的资料，大家可以自行查找。 我们通过引入express-session中间件来实现对会话的支持。 安装 express-session1npm i express-session --save 使用express-session12var session = require('express-session')app.use(session(options)) 使用给出的配置项来创建一个会话中间件。 更多关于options的详细参数可以看API。 解释session 中间件会在 req 上添加 session 对象，即 req.session 初始值为 {}，当我们登录后设置 req.session.user = 用户信息，返回浏览器的头信息中会带上 set-cookie 将 session id 写到浏览器 cookie 中，那么该用户下次请求时，通过带上来的 cookie 中的 session id 我们就可以查找到该用户，并将用户信息保存到 req.session.user。 express-formidable我们的注册功能里要求想要注册的用户必须上传头像，所以用到了上传功能。 Express是一个快速的，不收约束的，简约的nodejs的web框架； Formidable是一个解析表单数据的nodejs模块，包括多部分/格式文件上传； 所以，express-formidable是他们之前的一座桥梁，是一个强大的Express中间件 使用express-formidable1234567891011const express = require('express');const formidable = require('express-formidable');var app = express();app.use(formidable());app.post('/upload', (req, res) =&gt; &#123; req.fields; // contains non-file fields req.files; // contains files&#125;); 不包含文件的字段值使用 req.fields来接收； 文件字段的值使用req.files来接收； 配置项1app.use(formidable(opts)); 例如： 12345app.use(formidable(&#123; encoding: 'utf-8', uploadDir: '/my/dir', multiples: true, // req.files to be arrays of files&#125;); 注：想了解更多，可以点击这里。 用户模型设计用户注册时，需要的字段有： 用户名 用户密码 用户确认密码 用户性别 用户微博头像 用户简介 在了解了基本字段后，我们在lib/mongo.js里添加如下代码： 123456789// 用户模型设计exports.User = mongolass.model('User',&#123; name : &#123;type : 'string'&#125;, password : &#123;type : 'string'&#125;, gender : &#123;type : 'string',enum : ['m','f','x']&#125;, avatar : &#123;type : 'string'&#125;, intro : &#123;type : 'string'&#125;&#125;);exports.User.index(&#123; name : 1&#125;,&#123;unique : true&#125;).exec(); // 根据用户名找到用户，用户名全局唯一 说明 我们创建了用户的schema 生成并导出了User这个model 设置name为唯一索引，防止用户名重复 摞代码好了，到这一步，差不多该准备的工作都准备完了，那么就开始到编码阶段。 用户注册页在views/reg.js里添加如下代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;%- include('header') %&gt;&lt;form class="well form-horizontal" method="post" enctype="multipart/form-data"&gt; &lt;fieldset&gt; &lt;legend&gt;用户注册&lt;/legend&gt; &lt;div class="form-group" style="padding-left:15px"&gt; &lt;div style="float:left"&gt; &lt;label class="control-label" for="name"&gt;用户名&lt;/label&gt; &lt;/div&gt; &lt;p class="text-danger" style="color:red"&gt;*&lt;/p&gt; &lt;div class="controls"&gt; &lt;input type="form-control" class="form-control" id="name" name="name" style="width:20%;" placeholder="用户名"&gt; &lt;p class="help-block"&gt;你的帐号的名称，用于登录和显示&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group" style="padding-left:15px"&gt; &lt;div style="float:left"&gt; &lt;label class="control-label" for="password"&gt;密码&lt;/label&gt; &lt;/div&gt; &lt;p class="text-danger" style="color:red"&gt;*&lt;/p&gt; &lt;div class="controls"&gt; &lt;input type="password" class="form-control" id="password" name="password" style="width:20%;" placeholder="密码"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group" style="padding-left:15px"&gt; &lt;div style="float:left"&gt; &lt;label class="control-label" for="repassword"&gt;重复密码&lt;/label&gt; &lt;/div&gt; &lt;p class="text-danger" style="color:red"&gt;*&lt;/p&gt; &lt;div class="controls"&gt; &lt;input type="password" class="form-control" id="repassword" name="repassword" style="width:20%;" placeholder="再次输入密码"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group" style="padding-left:15px"&gt; &lt;div style="float:left"&gt; &lt;label class="control-label" for="gender"&gt;性别&lt;/label&gt; &lt;/div&gt; &lt;p class="text-danger" style="color:red"&gt;*&lt;/p&gt; &lt;div class="controls"&gt; &lt;select class="form-control" name="gender" style="width:20%"&gt; &lt;option value="m"&gt;男&lt;/option&gt; &lt;option value="f"&gt;女&lt;/option&gt; &lt;option value="x"&gt;保密&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group" style="padding-left:15px"&gt; &lt;div style="float:left"&gt; &lt;label class="control-label" for="exampleInputFile"&gt;头像&lt;/label&gt; &lt;/div&gt; &lt;p class="text-danger" style="color:red"&gt;*&lt;/p&gt; &lt;div class="controls"&gt; &lt;input type="file" id="exampleInputFile" name= "avatar"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group" style="padding-left:15px"&gt; &lt;div style="float:left"&gt; &lt;label class="control-label" for="introduction"&gt;简介&lt;/label&gt; &lt;/div&gt; &lt;p class="text-danger" style="color:red"&gt;*&lt;/p&gt; &lt;div class="controls"&gt; &lt;textarea class="form-control" rows="5" id="introduction" name="intro" style="width:60%"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;注册&lt;/button&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;% include footer.ejs %&gt; 路由文件在routes目录下新建reg.js文件，代码如下: 123456// 用户注册router.get('/',function (req, res, next) &#123; res.render('reg', &#123; title: '用户注册' &#125;);&#125;); 现在访问：localhost:3000/reg 可以看到用户注册页的效果了,如下图:未完待续，敬请关注]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手把手教你开发nodejs微博网站-连接数据库]]></title>
      <url>%2F2017%2F02%2F06%2FnodejsBlog-db%2F</url>
      <content type="text"><![CDATA[引子 博客肯定是以用户为中心，包括用户的注册，用户的登录，用户发表留言，对留言进行评价等等功能，所以，自然离不开数据库。本篇文章将涉及到三个名词: MongoDB,Robomongo,Mongolass。看完该文后，就对它们有一个清晰的认识了。 MongoDBMongoDB简介 MongoDB是一个开源的NoSql数据库，相比mysql那样的关系型数据库，它更为轻巧，灵活，非常适合在数据规模很大，事务性不强的场合下使用 MongoDB将数据存储为一个文档，数据结构由键值对(key=&gt;value)组成。字段值可以包含其他文档，数组及文档数组 相对于mysql这类需要把对象属性转换成SQL语句才能保存下来 ，MongoDB这些可以直接保存JS对象成数据库的文档，来看一个MongoDB文档的示例：123456&#123; "_id" : ObjectId( "4f7fe8432b4a1077a7c551e8" ), name : 'phping', age : 28, hobby : ['movies','music','nba']&#125; 可以看到数据格式为json，因此与javascript的亲和性很强，我们的项目也是使用MongoDB。 MongoD概念解析在mongodb中基本的概念是文档、集合、数据库。下表将帮助您更容易理解Mongo中的一些概念： SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据库记录集合/文档 column field 数据字段/域 index index 索引 table joins 表连接，mongodb不支持 primary key primary key 主键,MongoDB自动将_id字段设置为主键 通过下图实例我们也能更好的了解Mongo中的一些概念: MongoDB安装大家可以针对自己的系统，参考下面的向导来进行安装，步骤都是非常的详细。这里不再赘述。 Windows 用户向导：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/ Linux 用户向导：https://docs.mongodb.com/manual/administration/install-on-linux/ Mac 用户向导：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/ MongoDB可视化管理工具Robomongo我使用的MongoDB可视化管理工具是Robomongo,当然还有其它的可以使用，如:MongoChef等。 RobomongoRobomongo 是一个基于 Shell 的跨平台开源 MongoDB 管理工具。嵌入了 JavaScript 引擎和 MongoDB mogo 。只要你会使用 mongo shell ，你就会使用 Robomongo。提供语法高亮、自动完成、差别视图等。 点击这里下载 创建连接下载并安装成功后点击左上角的 Create 来创建一个连接，给该连接起个名字如: localhost，使用默认地址（localhost）和端口（27017）即可，点击 Save 保存，如下图： 添加数据前面已经简单的介绍了mongodb中的一些概念，让我们使用Robomongo这个图形化管理工具来添加数据: 点插入文档： 会打开一个空白面板，让我们手动写入要添加的数据： 写一个简单的测试数据如下：其中左下角的按钮可以用来验证我们写入的数据格式，数据格式无误后点击右下角的保存按钮即可。 查看新增加的文档: 这时，在你右边区域就可以看到我们刚才新增加的数据了: MongoDB驱动库Mongolass好了，MongoDB安装成功了，我们来使用Mongolass连接数据库。关于的更详细使用和api文档，可以点这里: http://mongoosejs.com/ http://mongoosejs.com/docs/guide.html https://www.npmjs.com/package/mongoose 安装Mongolass1$ npm install mongoose 连接MongoDB首先,我们需要定义一个连接。如果您的应用程序只使用一个数据库,您应该使用mongoose.connect；如果您需要创建额外的连接,使用mongoose.createConnection。 这两种方式连接都需要mongodb:// URI，或者主机名字，数据库名字，端口号，配置项等。123var mongoose = require('mongoose');mongoose.connect('mongodb://localhost/my_database'); 定义一个模型12345var mongoose = require('mongoose');mongoose.connect('mongodb://localhost/my_database');var Cat = mongoose.model('Cat', &#123; name: String &#125;); 访问一个模型1234567891011121314var mongoose = require('mongoose');mongoose.connect('mongodb://localhost/my_database');var Cat = mongoose.model('Cat', &#123; name: String &#125;);var kitty = new Cat(&#123; name: 'Zildjian' &#125;);kitty.save(function (err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log('meow'); &#125;&#125;); 更多使用可以查看官网文档. 总结本篇主要讲解了我在开发本项目时使用的什么数据库，怎么连接数据库，下节干货就来了:用户注册功能开发，敬请期待!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手把手教你开发nodejs微博网站-首页篇]]></title>
      <url>%2F2017%2F01%2F09%2FnodeJsBlog-index%2F</url>
      <content type="text"><![CDATA[引子 接着上一篇，本篇我们开始详细讲解用户首页的开发。 使用express-generator来快速搭建一个简单的网站，能够在浏览器里通过localhost:3000访问，输出：’Welcome to Express’ 表明搭建成功。 注明：只有上面的第二步安装成功，我们才能进行后面的工作。大家可以点这里有详细的介绍。 一.重中之重express-generator安装成功之后，在工程目录下面执行1npm start 然后在浏览器上访问: 1http://localhost:3000/ 输入如下： 看到没，一个简单的web网站已经搭建起来了，有了这个，我们在此基础上进行添砖加瓦，来为我们所用。 二. 目录结构在进行编码开发之前，先来看一下使用express-generator快速搭建网站后的目录结构如下： 在真正开发代码之前，我们温习一下MVC模型。 控制器(Controller)，一组行为的集合 模型(Model),数据相关的操作和封装 视图(View),视图的渲染 详细的解释我这里不再赘述了，大家若想深入了解可以去网上查阅相关资料。看完上面的目录结构，是缺少一个模型。我们在mytest目录下面新建一个models文件夹，就是用来存放于数据库打交道的模型。我们的微博网站是以用户为中心的，比如用户相关的信息需要保存到数据库里，或者从数据库里查询用户信息的。因此在新建的 models文件夹下面新建一个user.js,来帮我们做这些事儿，后面我们将会用到。 三.express.Router在添加路由之前，我先简单介绍一下express.Router。使用express.Router可以创建模块化，可安装的路由处理程序。一个express.Router实例是一个完整的中间件和路由系统。因此，它经常被称为一个迷你应用程序。我们来看官网的一个demo，先创建一个用来处理路由的文件birds.js:123456789101112131415161718var express = require('express')var router = express.Router()// middleware that is specific to this routerrouter.use(function timeLog (req, res, next) &#123; console.log('Time: ', Date.now()) next()&#125;)// define the home page routerouter.get('/', function (req, res) &#123; res.send('Birds home page')&#125;)// define the about routerouter.get('/about', function (req, res) &#123; res.send('About birds')&#125;)module.exports = router 然后加载上面定义的路由模块：123var birds = require('./birds')// ...app.use('/birds',birds) 这样这个应用程序就能够处理 /birds and /birds/about这些请求了，同时也能调用timeLog中间件功能特定的路由。具体想了解更多，更详细的语法，请点击这里，本篇文章中我不再赘述。 四.添加路由我们使用 express.Router来写路由中间件。在routes/index.js加载express.Router:1var router = express.Router() 然后就可以开始添加各种路由了。好，开始改代码了，是不是手痒痒。。。在routes/index.js修改添加展示首页的路由处理,如下：12345router.get('/',function (req,res) &#123; res.render('index',&#123; title : '首页' &#125;)&#125;) 五.加载路由在app.js里加载新添加的路由前，注意必须先加载路由文件哦。当然我们在使用express-generator时，app.js文件里已经加载过了，要不然那个默认页面是不会显示出来的。在app.js第8行后面添加代码：1var routes = require('./routes/index') 同时，删除掉第9行的代码。加载路由，修改25行代码为： 1app.use('/',routes) 六.访问首页在工程所在目录下，使用control + c 终止当前进程，然后重新启动执行，这样我们的修改才能生效:1npm start 在浏览器里访问： 1localhost:3000 输出如下： 七.小结是不是小有成就感，虽然做的东西很简单，但是毕竟开始了呀。当然，首页不可能会这么简单的，我会在后面的开发中继续完善首页，不要着急，一步一步深入。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手把手教你开发nodejs微博网站-开站篇]]></title>
      <url>%2F2016%2F12%2F31%2FnodejsBlog-start%2F</url>
      <content type="text"><![CDATA[手把手教你开发nodejs微博网站-开站篇引子 本项目参考Nodejs开发指南一书的第5章，受限于书中的nodejs和express版本太低，相当一部分代码在新版本的nodejs和express下都是无法使用,因此自己通过nodejs社区和参考网上的一些问题解决方式，最终完成了一个社交微博网站的雏形。 一.项目功能微博网站以用户为中心，包括: 用户注册 用户登录 用户发表信息 显示用户发表的信息 权限控制 其它功能 由于要保存用户信息，这里要牵涉到数据库连接，我使用的是Mongodb。本人也是nodejs的初学者，暂时先完成了着一些基本的功能。还有其它的功能点，比如:对微博的评论，转发等功能会在后面的学习中一步一步完善。 二.开发环境nodejs社区的版本更新比较频繁。列一下我的开发环境: 操作系统: OSX Yosemite 10.10.5 nodejs : v5.1.0 express : 4.14.0 MongoDB : 3.2.7 没有安装express的可以点我的另一篇文章,有详细的介绍。 三.项目截图:用户注册 用户登录 用户发表信息 显示用户发表的信息 登录密码错误在注册成功后，尝试登录时，如果密码错误，则提示: 四.权限控制比如，在未登录的情况下， 访问 /logout时，会提示: 用户已经登陆过时： 手动输入 /login后，不让render 登录页面，且提示已经登录 手动输入 /reg 后，不让render 注册页面，且提示已经登录 五.优化路由通过express.router和写公共中间件来优化路由 六.优化errHander当在测试环境下出现错误的路由时，会出现智能提示，显示错误信息 七.项目下载地址托管在github上:点这里大概情况就是这样，下一节开始详细讲解 用户注册模块，敬请大家关注。今天是2016年的最后一天，祝大家新年快乐，也希望我能把写博客的习惯带到2017年，给保留下去。我会在后面分篇陆续讲解每一个模块的实现，大家有什么情况可以给我留言。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nodejs新手小笔记之-express-generator安装]]></title>
      <url>%2F2016%2F12%2F19%2Fnodejs-install-express-generator%2F</url>
      <content type="text"><![CDATA[nodejs新手小笔记之-express-generator 上一篇简单的介绍了express的安装，这一篇我们来讲一下express-generator。 什么是express-generator先来看一下express 在github上的介绍，其中有一句话是这样说的:翻译一下大概意思是：开始使用express框架最快的方法是利用可执行express(1)生成一个应用程序如下所示:安装可执行文件。可执行的主要版本将匹配express:1$ npm install -g express-generator@4 那么，express-generator是个什么东东呢？解释一下express 4.0版本之前，有一个命令行工具 express,可以用来生成express模块的应用结构(网站结构)；express4.x之后，express命令被独立出来放在了express-generator模块中。 安装express-generator在知道了express-generator是什么东东后，我们来开始使用下面的命令来全局安装express这个命令行工具： npm install -g express-generator 安装完成后，可以使查看版本: $ express --version 4.14.0 显示命令选项使用-h参数可以显示命令选项，如下：12345678910111213141516$ express -h Usage: express [options] [dir] Options: -h, --help output usage information --version output the version number -e, --ejs add ejs engine support --hbs add handlebars engine support --pug add pug engine support -H, --hogan add hogan.js engine support -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade) -c, --css &lt;engine&gt; add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css) --git add .gitignore -f, --force force on non-empty directory 创建一个简单的网站好了，在知道一些基本的命令用法后，让我们来创建一个简单的网站吧：创建一个模板引擎为jade，应用名叫 mytest的工程，命令如下： 1$ express --view=jade mytest 回车后，输出如下：1234567891011121314151617181920212223create : mytestcreate : mytest/package.jsoncreate : mytest/app.jscreate : mytest/publiccreate : mytest/public/imagescreate : mytest/routescreate : mytest/routes/index.jscreate : mytest/routes/users.jscreate : mytest/public/javascriptscreate : mytest/public/stylesheetscreate : mytest/public/stylesheets/style.csscreate : mytest/viewscreate : mytest/views/index.jadecreate : mytest/views/layout.jadecreate : mytest/views/error.jadecreate : mytest/bincreate : mytest/bin/wwwinstall dependencies: $ cd mytest &amp;&amp; npm installrun the app: $ DEBUG=mytest:* npm start 按照提示，进入到mytest目录，然后安装依赖： $ cd mytest &amp;&amp; npm install 访问我们的网站安装完成后，启动我们的应用： $ npm start 注意：这个命令是 express4.x的版本 浏览器打开： 1http://localhost:3000/ 会看到一个输出，如下图： 至此，大功告成。好的，本篇文章到此结束，后面的系列就进入到实打实的代码开发阶段，敬请关注!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nodejs新手小笔记之-express安装]]></title>
      <url>%2F2016%2F12%2F17%2Fnodejs-install-express%2F</url>
      <content type="text"><![CDATA[nodejs新手小笔记之-express安装express概述Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。使用express我们可以快速的搭建一个网站。很多流行的nodejs框架都是基于express，例如：Feathers，ItemsAPIKeystoneJS等。 express安装注:前提是已经安装过node.js 创建一个目录用来当做你的工作目录，保存你的应用程序。 12$ mkdir myapp$ cd myapp 为你的应用创建一个包配置文件。如果想详细了解这个配置文件是如何工作的，可以点这里。 1$ npm init 执行这个命令后，会提示你一些信息，比如你想为你的应用程序起的名字,版本号,描述信息等。通常情况下，我们选默认的，直接回车即可。执行完毕后，会在myapp目录下面生成一个package.json文件，如下： 1234567891011&#123; "name": "myapp", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC"&#125; 如果我们想把main文件的名字起为app.js的话，可以在 entry point: (index.js) 的时候输入 app.js即可。 安装express配置文件生成后，就可以安装express框架了.1npm install express --save 命令执行完后，会生成一个 node_modules 目录，同时再次打开pack.json文件，会发现新添加了一个依赖列表，如下:1234567891011121314&#123; "name": "test2", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC", "dependencies": &#123; "express": "^4.14.0" &#125;&#125; 查看版本12express --version4.14.0 至此,express已经安装成功，是不是很简单呢…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nodejs之文件操作(fs模块)]]></title>
      <url>%2F2016%2F10%2F16%2Fnodejs-fs%2F</url>
      <content type="text"><![CDATA[Nodejs学习之文件操作文件操作NodeJS 提供一组类似 UNIX（POSIX）标准的文件操作API。 1.Node 导入文件系统模块Node 导入文件系统模块(fs)语法如下所示：1var fs = require("fs") 2.异步和同步 NodeJS能够操作文件。小至文件查找，大至代码编译。NodeJS文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。 3.文件拷贝NodeJS提供了基本的文件操作API，但是像文件拷贝这种高级功能就没有提供，因此我们先拿文件拷贝程序练手。与copy命令类似，我们的程序需要能接受源文件路径与目标文件路径两个参数。在编写拷贝程序之前，先来看几个函数的用法。 writeFileSync： 将文件内容写入目标路径1fs.writeFileSync(file, data[, options]) 解释： 1.file为目标路径2.data为文件内容 readFileSync： 读取文件1fs.readFileSync(file[, options]) 解释： 1.src为要读取的文件好，这两个重要的函数理清楚了之后，我们来编写一个文件拷贝程序。 process：进程，它是一个全局变量123process#The process object is a global that provides information about, and control over, the current Node.js process. As a global, it is always available to Node.js applications without using require(). 解释：process是一个全局变量，获取当前nodejs进程的信息。可以不用require(…)这样的语法而直接使用。 process脚本新建一个名为process.js的文件，内容如下：1console.log(process.argv) 执行process.js：1$ node process.js /Users/phping/Webserver/htdocs/nodejs/example.js 输出:123[ '/usr/local/Cellar/node/5.1.0/bin/node', '/Users/liuyongfei/Webserver/htdocs/nodejs/7days/process.js', '/Users/liuyongfei/Webserver/htdocs/nodejs/example.js' ] 解释: process.argv可以获得命令行参数，是一个数组。其中 argv[0]是NodeJS执行程序的绝对路径argv[1]为该脚本的绝对路径argv[2]为输入的参数 好了，几个重要的函数已经解释得差不多了，下面来看一个简单的拷贝脚本： Demo:文件拷贝little-file-copy.js12345678var fs = require('fs')function copy(src,dst) &#123; fs.writeFileSync(dst,fs.readFileSync(src))&#125;function main(argv) &#123; copy(argv[0],argv[1])&#125;main(process.argv.slice(2)) 执行脚本little-file-copy.js，并未该脚本传递两个参数，第一个参数是源文件(要拷贝的文件)，第二个参数为目标文件(将源文件拷贝到哪里)1$ node little-file-copy.js /Users/phping/Webserver/htdocs/nodejs/example.js /Users/phping/Webserver/htdocs/nodejs/7days/test/test.js 拷贝脚本解释： process.argv.slice(2)的结果如下： 12[ '/Users/liuyongfei/Webserver/htdocs/nodejs/example.js', '/Users/liuyongfei/Webserver/htdocs/nodejs/7days/test/test.js' ] 这两个元素分别作为copy的第一个和第二个参数，即： 12src等于'/Users/liuyongfei/Webserver/htdocs/nodejs/example.js'dst等于'/Users/liuyongfei/Webserver/htdocs/nodejs/7days/test/test.js' fs.readFileSync(src)读取源文件，并返回文件的内容 将文件内容写入目标路径 fs.writeFileSync(‘/Users/liuyongfei/Webserver/htdocs/nodejs/7days/test/test.js’ ，fs.readFileSync(‘/Users/liuyongfei/Webserver/htdocs/nodejs/example.js’)) 然后检查一下test目录下面的确生成一个了个test.js文件，且与example.js文件一样，则证明该脚本的拷贝功能成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从零开始nodejs系列之案例一：HTTP小爬虫]]></title>
      <url>%2F2016%2F10%2F07%2Fnodejs-demo1-crawler%2F</url>
      <content type="text"><![CDATA[一.前言 漫漫长路，从脚下开始；那么就从一个一个案例开始吧，在这个叫做blog的地方做为笔记记录下来。。。 二.案例一：HTTP小爬虫1. 从零开始nodejs系列之案例一：HTTP小爬虫本案例用来抓取慕课网的nodejs课程列表,如下： 2.爬虫抓取结果如下：注意：篇幅所限，这里我就截取了前三章的课程列表。 三.HTTP模块在讲HTTP小爬虫之前，先来大概介绍一下HTTP模块。关于HTTP的api，点这里，我这里就不一一列出来了。让我们从一个简单的例子开始。 1.需求 目的：建立一个lesson项目，通过在其中编写代码，当在浏览器中访问：http:://localhost:3000时，输出：Hello World 代码如下： 1234567891011121314const http = require(&apos;http&apos;);const hostname = &apos;127.0.0.1&apos;;const port = 3000;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader(&apos;Content-Type&apos;, &apos;text/plain&apos;); res.end(&apos;Hello World\n&apos;);&#125;);server.listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 在命令行中执行: 1$ node server.js 浏览器访问： 1http://localhost:3000/ 即可看到输出结果： 1$ Hello World 2.代码分析： 通过”require”引入NodeJS自带的”http”模块，并且把它赋值给http变量; “requestListener”这个回调函数，它提供了两个参数（request，response），我在代码里分别简写为req,res。每次收到一个请求时触发。 1http.createServer([requestListener]) 返回一个新的web服务器对象。参数 requestListener 是一个函数,它将会自动加入到 ‘request’ 事件的监听队列. statusCode是一个三位的HTTP状态码, 例如：”404” 。 1response.statusCode = 404; 当使用默认headers时（没有显式地调用 response.writeHead() 来修改headers），这个属性决定headers更新时被传回客户端的HTTP状态码。 setHeader 1response.setHeader(name, value) 为默认或者已存在的头设置一条单独的头内容。如果这个头已经存在于 将被送出的头中，将会覆盖原来的内容。如果我想设置更多的头， 就使用一个相同名字的字符串数组 server.listen(port, [hostname], [backlog], [callback]) 开始在指定的主机名和端口接收连接。如果省略主机名，服务器会接收指向任意IPv4地址的链接（INADDR_ANY）。 四.cheerio模块 抓取到网页之后如何获取到想要的数据呢？然后就发现了cheerio，用来解析html非常方便，就像在浏览器中使用jquery一样；为服务器特别定制的，快速、灵活、实施的jQuery核心实现。 github项目地址点这里。 安装1npm install cheerio API我们再来看cheerio的API举的例子 Markup example we’ll be using:12345&lt;ul id="fruits"&gt; &lt;li class="apple"&gt;Apple&lt;/li&gt; &lt;li class="orange"&gt;Orange&lt;/li&gt; &lt;li class="pear"&gt;Pear&lt;/li&gt;&lt;/ul&gt; LoadingFirst you need to load in the HTML. This step in jQuery is implicit, since jQuery operates on the one, baked-in DOM. With Cheerio, we need to pass in the HTML document.This is the preferred method:12var cheerio = require('cheerio'),$ = cheerio.load('&lt;ul id="fruits"&gt;...&lt;/ul&gt;'); SelectorsCheerio’s selector implementation is nearly identical to jQuery’s, so the API is very similar.12345678$('.apple', '#fruits').text()//=&gt; Apple$('ul .pear').attr('class')//=&gt; pear$('li[class=orange]').html()//=&gt; Orange AttributesMethods for getting and modifying attributes. .attr( name, value )Method for getting and setting attributes. Gets the attribute value for only the first element in the matched set. If you set an attribute’s value to null, you remove that attribute. You may also pass a map and function like jQuery.12345$('ul').attr('id')//=&gt; fruits$('.apple').attr('id', 'favorite').html()//=&gt; &lt;li class="apple" id="favorite"&gt;Apple&lt;/li&gt; 再看一个小demo12345var cheerio = require('cheerio')$ = cheerio.load('&lt;h2 class="title"&gt;Hello world&lt;/h2&gt;')$('h2.title').text('Hello there!')$('h2').addClass('welcome')console.log($.html()); 输出:1&lt;h2 class="title welcome"&gt;Hello there!&lt;/h2&gt; 等等，我就不再一一贴出来了，大家看一些这些语法，是不是就跟jquery的语法差不多呢。。。 HTTP模块和cheerio模块已经做了简单的介绍，详细的使用大家可以翻阅对应的API。好，准备工作也做得差不多了，让我们步入正题，开始来做HTTP爬虫吧。 HTTP爬虫所需模块 HTTP模块: 既然是HTTP小爬虫，肯定需要HTTP模块. cheerio模块: 抓取到网页之后如何获取到想要的数据,这个时候就需要cheerio，用来解析html非常方便，就像在浏览器中使用jquery一样。 ==开始摞码:== 一.代码区1加载所需模块 123var http = require('http')var cheerio = require('cheerio')var url = 'http://www.imooc.com/learn/348'; 代码解释 加载http模块; 加载cheerio模块; 指定要抓取的地址; 二.代码区2123456789101112http.get(url,function(res) &#123; var html = ''; res.on('data',function(data) &#123; html += data &#125;) res.on('end',function() &#123; var courseData = filterChapters(html) printCourseInfo(courseData) &#125;)&#125;).on('error',function() &#123; console.log('出错了哦')&#125;) 代码解释http.get(options, callback)12因为大部分的请求是没有报文体的GET请求，所以Node提供了这种便捷的方法。该方法与http.request()的唯一区别是它设置的是GET方法并自动调用req.end()。 http.request的用例如下：123456789101112// make a request var options = &#123; port: 1337, hostname: '127.0.0.1', headers: &#123; 'Connection': 'Upgrade', 'Upgrade': 'websocket' &#125; &#125;; var req = http.request(options); req.end(); response.end 结束响应，告诉客户端所有消息已经发送。当所有要返回的内容发送完毕时，该函数必须被调用一次。如何不调用该函数，客户端将永远处于等待状态。 filterChapters函数filterChapters函数为封装好的过滤html的函数1234567891011121314151617181920212223242526272829303132333435function filterChapters(html) &#123; var $ = cheerio.load(html) var charpters = $('.chapter') var courseData = [] charpters.each(function(item) &#123; var chapter = $(this) var chapterTmpTitle = chapter.find('strong').clone() chapterTmpTitle.find('div').remove() // var chapterTitle = chapter.find('strong').text() var chapterTitle = chapterTmpTitle.text().match(/\S+\s\S+/) var videos = chapter.find('.video').children('li') var chapterData = &#123; chapterTitle: chapterTitle, videos: [] &#125; videos.each(function(item) &#123; var video = $(this).find('.J-media-item') var videoTmpTitle = video.clone() videoTmpTitle.find('button').remove() var videoTitle = videoTmpTitle.text().match(/[0-9]+-[0-9]+\s\S*\s?\S*/) // console.log(chapterTitle) // var videoTitle = video.text() var id = video.attr('href').split('video/')[1] chapterData.videos.push(&#123; title : videoTitle, id: id &#125;) &#125;) courseData.push(chapterData) &#125;) return courseData&#125; printCourseInfo函数printCourseInfo函数用来打印课程信息的函数123456789function printCourseInfo(courseData) &#123; courseData.forEach(function(item) &#123; var chapterTitle = item.chapterTitle console.log(chapterTitle + '\n') item.videos.forEach(function(video) &#123; console.log(' 【' + video.id + ' 】' + video.title + '\n') &#125;) &#125;)&#125; 好了，主要代码大概就是这些。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手把手教你实现echarts3的折线图下钻drilldown功能系列篇二]]></title>
      <url>%2F2016%2F09%2F21%2Fecharts-line-drill-down-code%2F</url>
      <content type="text"><![CDATA[开场白 好了,上一篇介绍了关于echarts下钻（drilldown）的一些信息，通过上一篇文章我们知道echarts折线图，柱状图没有支持下钻（drilldown）功能的api，那就需要我们自己动手，丰衣足食了。这一篇我开始进行实质性的代码演示。你可以按照我的步骤一步一步来做，有什么疑问可以留言我。 一.效果贴图为了避免枯燥无味，我先不贴代码，写贴上我的demo图,这里还会拿上一篇的那个demo图为例。 1.下钻（drilldown）前效果 从图可以看出：这是展示2016年1月一直到2016年9月份的数据的折线图。 下钻（drilldown）开始：比如我点击2016年9月份(201609)的这个点，则应该显示一个属于2016年9月份下的每一天的一个折线图。 2.下钻（drilldown）后效果： 从图可以看出：这是展示的从2016年9月份0901号开始直到0930号这30天的一个折线图。完全符合我们的要求，对吧。 3.返回父级所在折线图 这里我提供了一个返回按钮，点击返回按钮后，会重新返回到父级的折线图: 4.总结 由这3张图我们能够看出一个标准的折线图下钻（drilldown）功能就出来了。 那么，实现起来复杂了，其实也很简单。因为我们有万能的 setOption 函数。 不废话了，下面开始贴出详细的代码，准备好了吗？ 注意：如果有对echarts的最基础的使用还不太了解的话，建议去 官网 看看api和教程之类的，我这里就不再对基础的只是进行赘述了。 二.折线图界面line-drill-down.html12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html style="height: 100%"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;body style="height: 100%; margin: 0"&gt; &lt;div style="margin-left:40%;margin-top:2%"&gt; &lt;button id='return-button' value=''&gt;返回&lt;/button&gt; &lt;/div&gt; &lt;div id="container" style="height: 50%;width: 50%"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/echarts-all-3.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./drillDown.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var dom = document.getElementById("container"); var myChart = echarts.init(dom); var option = drillDown.getOption(); //获取配置 drillDown.initChart(myChart,option); // 初始化加载折线图，并显示出来 // 点击返回按钮，会重新回到一.1的折线图 $('#return-button').on('click',function()&#123; var myChart = echarts.init(dom); var option = drillDown.getOption(); drillDown.initChart(myChart,option); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 代码解释： 10行：在绘图前我们需要为 ECharts 准备一个具备高宽的 DOM 容器; 13行：加载了一个drillDown.js文件，详细代码见下面的第三步; 61，62行：基于准备好的dom，初始化echarts实例; 63行：指定图表的配置项; 64行：使用封装好的initChart方法为图表填充数据，并使用63行的配置项和64行的数据来显示图表. 这里都是echarts的基础知识，详细的可以点击这里进行充电。 三.drillDown.js代码在这个js文件里我封装了几个方法: getOption: 获取当前echart对象的配置数组，我就不再详细讲解了。 initChart: 初始化折线图，这个方法做了两件事： 显示图表; 为图表添加点击事件，也就是点击 返回按钮时触发的事件，详细逻辑看代码。 看代码： 123456789101112131415161718192021222324var drillDown = &#123; getOption : function () &#123; var option = null; option = &#123; title: &#123; text: '折线图下钻（drilldown）示例', left: 'center' &#125;, tooltip: &#123; trigger: 'item', formatter: '&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125;' &#125;, legend: &#123; left: 'left', data: ['月数据'] &#125;, xAxis: &#123; type: 'category', name: 'x', splitLine: &#123;show: false&#125;, data: ['201601', '201602', '201603', '201604', '201605', '201606', '201607', '201608', '201609'] &#125;, ......&#125;; 由于代码篇幅过长，影响阅读性，我这里不详细贴出，大家可以从这里下载。 四.后台数据接口代码data.php这里我写了伪代码，大家看一下应该就能够明白了:1234567891011121314151617181920212223&lt;?php // 这里的接口代码伪代码大概如下: function getInterfaceData($month) &#123; // 1.写查询语句,这里只是写伪代码,自己做防sql注入 $sql = "select ... from table where month = $month"; // 2.连接数据库,查询结果为$data // 3.对查询的结果进行组装,返回json格式的数组 $chartResult = []; // 4.取出x轴的值 $chartResult['xAxis'] = $data['report_date']; // 5.为第一个series赋值，我们这里的demo只有一条折线 $yAxisArr['yAxis'][0] = $data['data0']; // 如果有多条折线的情况下,可以这样写 // $yAxisArr['yAxis'][1] = $data['data1']; // $yAxisArr['yAxis'][2] = $data['data2']; // 6.为y轴赋值 $chartResult['yAxis'] = $yAxisArr; // 7.返回json格式的数据 exit(json_encode($chartResult)); &#125;?&gt; 说明:data.php每一步我都有详细的注释，该方法主要是返回一个json格式的字符串，来供ajax回调使用。 客户端再拿到这个json字符串后，再进行拆分，分别给图表的x轴和y轴赋值即可。 五.代码下载 demo下载点击 这里。 后续更新 有下载过demo代码的小伙伴反应，点击月份的一个点时(比如点2016-09月份)，虽然会下钻出来09月份下的每一个天的数据，但是同时2016-09月份数据的这个点却仍然在，如下图： 1.场景描述经了解后发现，代码都是从我的github仓库clone下来的，唯一不一样的是小伙伴儿是在windows操作系统上运行的，而在mac上根本没有这个情况，此时只有这张图能代表我的心情… 2.原因分析原因猜想这个地方应该是一个echarts的bug，应该是下钻前和下钻后共用一个dom容器产生的原因。估计开发者们也都是用mac开发的，故没有发现，瞎猜哈。 3.解决办法我的优化办法：click后，销毁之前的echarts实例，重新初始化一个就好了。 那就见招拆招吧,在drillDown.js文件里添加如下两行代码1234// 销毁之前的echarts实例echarts.dispose(dom);// 初始化一个新的实例var myChart = echarts.init(dom); 代码已经更新，大家可以从这里下载，clone过后别忘了赏个start。。。 六.总结 好了，如果在第二部分中直接使用我模拟的测试数据的话，可以先不理会data.php的代码。直接打开line-drill-down.html运行即可测试; 跑通后，需要与后台接口打通时，可以看一下data.php的一个思路，根据自己的业务写逻辑，然后再说测试即可; 大家在测试的过程中有什么问题，可以跟我留言，我会在第一时间回复; 码字不易，转载请注明出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手把手教你实现echarts3的折线图下钻drilldown功能系列篇一]]></title>
      <url>%2F2016%2F09%2F19%2Fecharts-line-drill-down%2F</url>
      <content type="text"><![CDATA[一.抛出需求：折线图-下钻功能 最近接到领导的一个需求:说是想在原来的月份数据的折线图上，点击某个月份后能显示一个该月份对应的每一天的一个折线图。 折线图图一如下： 领导的意图是:比如，点击201609月份这个点后,能够出现一个新的折线图，显示的是201609月份的每一天的数据。 需求看到这里,相信以前接触或使用过highcharts的童鞋就知道了，这是一个下钻的功能。 我的项目现在使用的是echarts3，以前是用过highcharts 二.highcharts的下钻功能1.看图表我们来看highcharts官网的一个例子,显示的是各个主流浏览器的一个数值比重，我这里截图如图二所示： 然后点击随意的一个柱子，会出现一个新的图表,如下图图三:(我点击的是第一个柱子:IE浏览器)： 从图三可以看出： 显示的是 IE浏览器的各个版本使用率的占比. 点击圈红的后退按钮，可以返回上一级的图表. 2.看API看一下API对钻取的支持： 3.疑问既然highcharts对下钻功能支持那么好，那么echarts在这一块做的怎么样呢？ 三.echarts的下钻功能-drilldown1.看图表翻了半天，只找到一个矩形树图的例子，类似有那么点下钻的意思，感觉很鸡肋。想了解的点这里。 2.看API只找到了series的type=treemap类型，如图四： 是不是感觉好鸡肋呀，折线图，柱状图的这些都不支持下钻。。。 3.echarts项目issue区域3.1 去github的echarts项目issue区域看了看，发现已经有了好几条关于钻取的问题，如图五: 3.2 然后点最下面的一条件进去看了看，返现是echarts的作者林峰的回复，哈哈，终于看见大神了。 4.翻译一下好吧，翻译一下：大概意思就是告诉我们echarts不会提供什么钻取的接口，大家要想使用钻取功能，请使用万能的setOption吧。。。 四.总结看到这里你大概会想说： BB了那么久，怎么还不入正题呢？ echarts的折线图究竟怎么来实现下钻(drilldown)功能呢？ 五.未完待续 不要着急，本篇主要讲了一下遇见需求后分析问题和解决问题的一些思路。 下篇 我会从代码的角度详细介绍怎么一步一步来实现，敬请关注! 码字不易，转载请注明出处!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[echarts3的折线图怎么分段显示不同的颜色]]></title>
      <url>%2F2016%2F06%2F05%2Fecharts3-series-different-color%2F</url>
      <content type="text"><![CDATA[本篇文章主要讲解在echarts3的折线图怎么分段显示不同的颜色。 一.场景在使用echarts3做图表的时候，可能会遇到一些特殊的需求： 星期一到星期四这几个点的折线显示一个颜色，周五到周日这几个点的折线显示另外一个颜色，来起到强调区别的作用。 二.效果图先看一下效果图，你会有一个更清晰的认识: 从图中大家可以看到,整个折线图分了2段颜色：周一到周四的折线是红色，周五到周日的折线是黑色。这样一来，是不是就有个很明显的强调区别的作用啦。 demo下载点击这里。 那么，怎么去实现这个效果呢?别着急，一步一步来，往下看。 三.echarts3的api支持吗看到这样的需求，第一反应就是去api里看看有支持的函数没。。。在api找到半天，果然不支持。领导非要这样做，echarts3的api里又不支持，那么怎么办？答案：换思路 四.思路1.折线图的数据点在哪里被赋值的?我们知道在echarts中图表是通过series来实现的： 其中圈红的第一个就是图形类型为折线图时用到的配置，折线图的这些数据点都是通过里面的这个data数组来生成的。 2.拆分为多个series 将一个完整的折线分成两段折线，不同的折线显示不同的颜色即可。 我们知道周一到周日总共是7个点，series的data数据为:1234567series: [ &#123; name: &apos;指数&apos;, type: &apos;line&apos;, data: [4, 8, 16, 32, 64, 128, 256] &#125; ] 如果拆分成两段折线的话，就得用两个series,两个series就得有两个数据集(data数组). 其中第一个series的数据集为:14, 8, 16, 32, 64 第二个series的数据集为:1128,256 但是在echarts中，图形的每一个点都要有与x轴和y轴对应的，否则，画出来的图形是与数据对应不上的。 所以我们需要对上面的两个数组进行一下改造。 3.普及一小技巧在echarts中，若是不想让某个点展示，则这个点对应的data数值可以用’-‘来表示。反正这个知识点没有在echarts3的api里提到，应该在echarts2中继承下来的知识点吧。 4.转化数据集知道上面这个小技巧后，我们就可以把这两个数据集写成下面这种格式了:series[0].data:1[4, 8, 16, 32, 64,&apos;-&apos;,&apos;-&apos;] series[1].data:1[&apos;-&apos;,&apos;-&apos;,&apos;-&apos;,&apos;-&apos;,&apos;-&apos;,128,256] 五.摞代码既然思路都有了，那么我们开始试试吧。 1.option的配置和主要代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// blog: phping.sinaapp.comvar dom = document.getElementById(&quot;container&quot;);var myChart = echarts.init(dom);option = null;option = &#123; title: &#123; text: &apos;echarts3的折线图分段显示不同的颜色&apos;, left: &apos;center&apos;, link: &apos;http://phping.sinaapp.com&apos; &#125;, tooltip: &#123; trigger: &apos;item&apos;, formatter: &apos;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125;&apos; &#125;, legend: &#123; left: &apos;left&apos;, data: [&apos;指数&apos;] &#125;, xAxis: &#123; type: &apos;category&apos;, name: &apos;x&apos;, splitLine: &#123;show: false&#125;, data: [&apos;星期一&apos;, &apos;星期二&apos;, &apos;星期三&apos;, &apos;星期四&apos;, &apos;星期五&apos;, &apos;星期六&apos;, &apos;星期日&apos;] &#125;, grid: &#123; left: &apos;3%&apos;, right: &apos;4%&apos;, bottom: &apos;3%&apos;, containLabel: true &#125;, yAxis: &#123; type: &apos;log&apos;, name: &apos;y&apos; &#125;, series: [ &#123; name: &apos;指数&apos;, type: &apos;line&apos;, data:[] &#125;, &#123; name: &apos;指数&apos;, type: &apos;line&apos;, data:[] &#125; ]&#125;;if (option &amp;&amp; typeof option === &quot;object&quot;) &#123; var startTime = +new Date(); option.series[0].data = [4, 8, 16, 32, 64,&apos;-&apos;,&apos;-&apos;]; option.series[1].data = [&apos;-&apos;,&apos;-&apos;,&apos;-&apos;,&apos;-&apos;,64,128,256]; myChart.setOption(option, true);&#125; 2.走一个试试: ==两条线是分出来了，但是中间是有个断点。如果你觉得这样影响需求的话，则直接在series[1].data里把这个点补出来即可。== 2.1原来的格式:12option.series[0].data = [4, 8, 16, 32, 64,&apos;-&apos;,&apos;-&apos;];option.series[1].data = [&apos;-&apos;,&apos;-&apos;,&apos;-&apos;,&apos;-&apos;,&apos;-&apos;,128,256]; 2.2修改为现在的格式:12option.series[0].data = [4, 8, 16, 32, 64,&apos;-&apos;,&apos;-&apos;];option.series[1].data = [&apos;-&apos;,&apos;-&apos;,&apos;-&apos;,&apos;-&apos;,64,128,256]; 再次刷新，是不是两条断线连上了呢。效果就跟文首的demo是一样的了。 六.总结 遇见此类需求时，先看看api里提供了类似的方法没有,有的话，就不用费大头筋儿了； 没有的话，就得转变思路了，将一个折线分成多个折线。 巧妙利用四.3中的小知识点来绘制空点 实际开发中可能要比这个demo要复杂一些，但是基本思路都是一样的。 demo下载点击这里。 码字不易，转载请注明出处。]]></content>
    </entry>

    
  
  
</search>
